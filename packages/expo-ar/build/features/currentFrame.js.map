{"version":3,"file":"currentFrame.js","sourceRoot":"","sources":["../../src/features/currentFrame.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,oBAAoB,EAAE,MAAM,mBAAmB,CAAC;AACzD,OAAO,EAAE,QAAQ,EAAE,MAAM,aAAa,CAAC;AASvC;;;GAGG;AACH,MAAM,CAAN,IAAY,cAMX;AAND,WAAY,cAAc;IACxB,qCAAmB,CAAA;IACnB,mCAAiB,CAAA;IACjB,uDAAqC,CAAA;IACrC,qDAAmC,CAAA;IACnC,yDAAuC,CAAA;AACzC,CAAC,EANW,cAAc,KAAd,cAAc,QAMzB;AAsBD,MAAM,CAAN,IAAY,gBAGX;AAHD,WAAY,gBAAgB;IAC1B,iDAA6B,CAAA;IAC7B,mDAA+B,CAAA;AACjC,CAAC,EAHW,gBAAgB,KAAhB,gBAAgB,QAG3B;AAED,MAAM,CAAN,IAAY,iBAGX;AAHD,WAAY,iBAAiB;IAC3B,6DAAwC,CAAA;IACxC,6DAAwC,CAAA;AAC1C,CAAC,EAHW,iBAAiB,KAAjB,iBAAiB,QAG5B;AAoBD,MAAM,CAAN,IAAY,SAIX;AAJD,WAAY,SAAS;IACnB,kCAAqB,CAAA;IACrB,gEAAmD,CAAA;IACnD,oEAAuD,CAAA;AACzD,CAAC,EAJW,SAAS,KAAT,SAAS,QAIpB;AAAA,CAAC;AAmCF,IAAK,2BAGJ;AAHD,WAAK,2BAA2B;IAC9B,8CAAe,CAAA;IACf,kDAAmB,CAAA;AACrB,CAAC,EAHI,2BAA2B,KAA3B,2BAA2B,QAG/B;AAkBD,SAAS,oBAAoB,CAAC,eAA4D;IACxF,OAAO,CAAC,CAAE,eAAsC,CAAC,gBAAgB,CAAC;AACpE,CAAC;AAED,SAAS,wBAAwB,CAAC,eAA4D;IAC5F,OAAO,CAAC,CAAE,eAA0C,CAAC,cAAc,CAAC;AACtE,CAAC;AAED,SAAS,oCAAoC,CAAC,eAA4D;IACxG,IAAI,oBAAoB,CAAC,eAAe,CAAC,EAAE;QACzC,MAAM,EAAE,uBAAuB,EAAE,gBAAgB,EAAE,GAAG,eAAe,CAAC;QACtE,MAAM,EAAE,GAAG,EAAE,KAAK,EAAE,IAAI,EAAE,GAAG,oBAAoB,CAAC,uBAAuB,CAAC,CAAC;QAC3E,OAAO;YACL,GAAG;YACH,KAAK;YACL,IAAI;YACJ,gBAAgB;YAChB,GAAG,EAAE,eAAe;SACrB,CAAC;KACH;IACD,IAAI,wBAAwB,CAAC,eAAe,CAAC,EAAE;QAC7C,OAAO;YACL,GAAG,eAAe;YAClB,OAAO,EAAE,eAAe;SACzB,CAAC;KACH;IACD,MAAM,IAAI,KAAK,CAAC,kEAAkE,IAAI,CAAC,SAAS,CAAC,eAAe,CAAC,EAAE,CAAC,CAAC;AACvH,CAAC;AAWD;;;GAGG;AACH,MAAM,CAAC,KAAK,UAAU,oBAAoB,CAAC,UAA6B;IACtE,MAAM,KAAK,GAAG,MAAM,QAAQ,CAAC,oBAAoB,CAAC,UAAU,CAAC,CAAC;IAC9D,IAAI,UAAU,CAAC,cAAc,CAAC,eAAe,CAAC,EAAE;QAC9C,KAAK,CAAC,eAAe,GAAG,oCAAoC,CAAC,KAAK,CAAC,eAAe,CAAC,CAAC;KACrF;IACD,OAAO,KAAK,CAAC;AACf,CAAC","sourcesContent":["import { colorTemperature2rgb } from 'color-temperature';\nimport { NativeAR } from '../NativeAR';\nimport {\n  Anchor,\n  BlendShape,\n  Size,\n  Vector3,\n  Matrix4,\n} from '../commons';\n\n/**\n * Attributes that are available to be queried from current frame.\n * See {@link getCurrentFrameAsync}\n */\nexport enum FrameAttribute {\n  Anchors = 'anchors',\n  Planes = 'planes',\n  RawFeaturePoints = 'rawFeaturePoints',\n  LightEstimation = 'lightEstimation',\n  CapturedDepthData = 'capturedDepthData',\n}\n\nexport type ARFrameAttributes = {\n  [FrameAttribute.Anchors]?: {\n    ARFaceTrackingConfiguration?: {\n      geometry?: boolean;\n      blendShapes?: boolean | BlendShape[];\n    };\n  };\n  [FrameAttribute.RawFeaturePoints]?: boolean;\n  [FrameAttribute.Planes]?: boolean;\n  [FrameAttribute.LightEstimation]?: boolean;\n  [FrameAttribute.CapturedDepthData]?: boolean;\n};\n\nexport type RawFeaturePoint = {\n  x: number;\n  y: number;\n  z: number;\n  id: string;\n};\n\nexport enum DepthDataQuality {\n  Low = 'AVDepthDataQualityLow',\n  High = 'AVDepthDataQualityHigh',\n}\n\nexport enum DepthDataAccuracy {\n  Absolute = 'AVDepthDataAccuracyAbsolute',\n  Relative = 'AVDepthDataAccuracyRelative',\n}\n\nexport type CameraCalibrationData = {\n  intrinsicMatrix: number[];\n  intrinsicMatrixReferenceDimensions: Size;\n  extrinsicMatrix: number[];\n  pixelSize: number;\n  lensDistortionLookupTable: any;\n  inverseLensDistortionLookupTable: any;\n  lensDistortionCenter: Vector3;\n};\n\nexport type CapturedDepthData = {\n  timestamp: number;\n  depthDataQuality: DepthDataQuality;\n  depthDataAccuracy: DepthDataAccuracy;\n  depthDataFiltered: boolean;\n  cameraCalibrationData: CameraCalibrationData;\n};\n\nexport enum PlaneType {\n  VERTICAL = 'vertical',\n  HORIZONTAL_UPWARD_FACING = 'horizontalUpwardFacing',\n  HORIZONTAL_DOWNWARD_FACING = 'horizontalDownwardFacing'\n};\n\nexport type Plane = {\n  id: number;\n  worldTransform: Matrix4;\n  extent: {\n    width: number;\n    length: number;\n  };\n  center: {\n    x: number;\n    y: number;\n    z: number;\n  };\n  parent?: Plane;\n  planeType: PlaneType;\n  anchors?: Anchor[];\n};\n\nexport type LightEstimation = {\n  red: number;\n  green: number;\n  blue: number;\n  \n  // @only Android: value is between (0.0, 1.0), with zero being black and one being white.\n  pixelIntensity?: number;\n  \n  // @only iOS: ambient intensity, in lumens, of ambient light throughout the scene. A value of 1000 represents \"neutral\" lighting.\n  // see: https://en.wikipedia.org/wiki/Shading#Ambient_lighting\n  ambientIntensity?: number;\n\n  iOS?: LightEstimationIOS;\n  android?: LightEstimationAndroid;\n};\n\nenum LightEstimationAndroidState {\n  VALID = 'valid',\n  INVALID = 'invalid'\n}\n\ntype LightEstimationAndroid = {\n  red: number;\n  green: number;\n  blue: number;\n  pixelIntensity: number; // see LightEstimation.pixelIntensity\n  state: LightEstimationAndroidState;\n}\n\ntype LightEstimationIOS = {\n  ambientIntensity: number; // see LightEstimation.ambientIntensity\n  \n  // The estimated color temperature, in degrees Kelvin\n  // A value of 6500 represents neutral (pure white) lighting; lower values indicate a \"warmer\" yellow or orange tint, and higher values indicate a \"cooler\" blue tint.\n  ambientColorTemperature: number;\n}\n\nfunction isLightEstimationIOS(lightEstimation: LightEstimationAndroid | LightEstimationIOS): lightEstimation is LightEstimationIOS {\n  return !!(lightEstimation as LightEstimationIOS).ambientIntensity;\n}\n\nfunction isLightEstimationAndroid(lightEstimation: LightEstimationAndroid | LightEstimationIOS): lightEstimation is LightEstimationAndroid {\n  return !!(lightEstimation as LightEstimationAndroid).pixelIntensity;\n}\n\nfunction handleLightEstimationInconsistencies(lightEstimation: LightEstimationAndroid | LightEstimationIOS): LightEstimation {\n  if (isLightEstimationIOS(lightEstimation)) {\n    const { ambientColorTemperature, ambientIntensity } = lightEstimation;\n    const { red, green, blue } = colorTemperature2rgb(ambientColorTemperature);\n    return {\n      red,\n      green,\n      blue,\n      ambientIntensity,\n      iOS: lightEstimation,\n    };\n  }\n  if (isLightEstimationAndroid(lightEstimation)) {\n    return {\n      ...lightEstimation,\n      android: lightEstimation,\n    };\n  }\n  throw new Error(`getCurrentFrameAsync#LightEstimation returned unknown results: ${JSON.stringify(lightEstimation)}`);\n}\n\nexport type ARFrame = {\n  timestamp: number;\n  [FrameAttribute.Anchors]?: Anchor[];\n  [FrameAttribute.RawFeaturePoints]?: RawFeaturePoint[];\n  [FrameAttribute.Planes]?: Plane[];\n  [FrameAttribute.LightEstimation]?: LightEstimation;\n  [FrameAttribute.CapturedDepthData]?: CapturedDepthData | null;\n};\n\n/**\n * Requests data from current frame.\n * @param attributes Specification which data to query from frame.\n */\nexport async function getCurrentFrameAsync(attributes: ARFrameAttributes): Promise<ARFrame> {\n  const frame = await NativeAR.getCurrentFrameAsync(attributes);\n  if (attributes[FrameAttribute.LightEstimation]) {\n    frame.lightEstimation = handleLightEstimationInconsistencies(frame.lightEstimation);\n  }\n  return frame;\n}\n"]}